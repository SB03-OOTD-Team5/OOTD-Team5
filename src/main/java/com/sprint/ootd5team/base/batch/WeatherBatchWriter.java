package com.sprint.ootd5team.base.batch;

import static com.sprint.ootd5team.base.util.DateTimeUtils.DATE_FORMATTER;
import static com.sprint.ootd5team.base.util.DateTimeUtils.SEOUL_ZONE_ID;
import static com.sprint.ootd5team.base.util.DateTimeUtils.TIME_FORMATTER;

import com.sprint.ootd5team.domain.location.dto.data.LocationWithProfileIds;
import com.sprint.ootd5team.domain.location.entity.Location;
import com.sprint.ootd5team.domain.location.repository.LocationRepository;
import com.sprint.ootd5team.domain.notification.service.NotificationService;
import com.sprint.ootd5team.domain.weather.entity.Weather;
import com.sprint.ootd5team.domain.weather.enums.PrecipitationType;
import com.sprint.ootd5team.domain.weather.enums.SkyStatus;
import com.sprint.ootd5team.domain.weather.external.WeatherExternalAdapter;
import com.sprint.ootd5team.domain.weather.external.WeatherFactory;
import com.sprint.ootd5team.domain.weather.external.context.ForecastIssueContext;
import com.sprint.ootd5team.domain.weather.repository.WeatherRepository;
import com.sprint.ootd5team.domain.weather.service.WeatherService;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class WeatherBatchWriter implements ItemWriter<LocationWithProfileIds> {

    private final WeatherFactory weatherFactory;
    private final WeatherExternalAdapter externalAdapter;
    private final WeatherService weatherService;
    private final NotificationService notificationService;
    private final WeatherRepository weatherRepository;
    private final LocationRepository locationRepository;

    public WeatherBatchWriter(Map<String, WeatherFactory> weatherFactories,
        Map<String, WeatherExternalAdapter> externalAdapters, WeatherService weatherService,
        NotificationService notificationService, WeatherRepository weatherRepository,
        LocationRepository locationRepository,
        @Value("${weather.api-client.provider}") String provider) {
        this.weatherFactory = resolveFactory(weatherFactories, provider);
        this.externalAdapter = resolveAdapter(externalAdapters, provider);
        this.weatherService = weatherService;
        this.notificationService = notificationService;
        this.weatherRepository = weatherRepository;
        this.locationRepository = locationRepository;
    }

    @Override
    public void write(Chunk<? extends LocationWithProfileIds> chunk) throws Exception {
        try {
            ZonedDateTime issueDate = ZonedDateTime.now(SEOUL_ZONE_ID);
            LocalTime issueTime = externalAdapter.resolveIssueTime(issueDate);
            log.info("[WeatherBatchWriter] write start chunkSize={} issueDate={} issueTime={}",
                chunk.size(), issueDate, issueTime);
            ForecastIssueContext issueContext = weatherFactory.createForecastIssueContext(
                issueDate);

            // chunkÏóê ÏûàÎäî Îç∞Ïù¥ÌÑ∞Î•º fetchÌï®
            for (LocationWithProfileIds item : chunk) {
                List<UUID> profileIds = item.profileIds();

                if (item.locationId() == null) {
                    log.info("[WeatherBatchWriter] locationId Ï†ïÎ≥¥Í∞Ä ÏóÜÏñ¥ Í±¥ÎÑàÎúÄ profiles={}", profileIds);
                    continue;
                }

                Location location = locationRepository.findById(item.locationId()).orElse(null);
                if (location == null) {
                    log.info("[WeatherBatchWriter] location ÏóîÌã∞Ìã∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå locationId={} profiles={}",
                        item.locationId(), profileIds);
                    continue;
                }

                // 1. ÎÇ†Ïî® Ï∞æÍ∏∞
                List<Weather> weathers = weatherFactory.findWeathers(location, issueContext);
                if (weathers.isEmpty()) {
                    // 2. ÎÇ†Ïî® Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞
                    String baseDate = issueContext.getIssueDateTime().format(DATE_FORMATTER);
                    String baseTime = issueContext.getIssueDateTime().format(TIME_FORMATTER);
                    Object response = externalAdapter.getWeather(item.latitude(),
                        item.longitude(), baseDate, baseTime, 300);
                    log.info("[WeatherBatchWriter] Ïô∏Î∂Ä API Ìò∏Ï∂ú ÏôÑÎ£å locationId={} lat={} lon={}",
                        location.getId(), item.latitude(), item.longitude());

                    // 3. ÎÇ†Ïî® ÏÉùÏÑ±
                    weathers = weatherFactory.createWeathers(response,
                        null,
                        issueContext,
                        location);
                    weatherRepository.saveAll(weathers);
                    log.info("[WeatherBatchWriter] ÏÉà weather {}Í±¥ Ï†ÄÏû• locationId={}}",
                        weathers.size(),
                        location.getId());

                }

                createNotification(location, issueContext, weathers, profileIds);

            }

        } catch (Exception e) {
            log.error("[WeatherBatchWriter] Ï≤òÎ¶¨ Ïã§Ìå®: chunk size={} ÏõêÏù∏={}", chunk.size(),
                e.getMessage(), e);
            throw e;
        }
    }

    private void createNotification(Location location, ForecastIssueContext issueContext,
        List<Weather> weathers, List<UUID> profileIds) {
        //  ÎÇ†Ïî®Ï†ïÎ≥¥ÏôÄ ÎßàÏßÄÎßâÏúºÎ°ú Ï†ÄÏû•Îêú Ïò§Îäò ÎÇ†Ïî®Ï†ïÎ≥¥Î•º ÎπÑÍµê -> Ï∞®Ïù¥Í∞Ä ÌÅ¨Î©¥ ÏïåÎ¶º Î≥¥ÎÉÑ
        Weather latestTodayWeather = weatherService.getLatestWeatherForLocationAndDate(
            location.getId(), LocalDate.now(SEOUL_ZONE_ID));

        //  weathers Ï§ë Îã§ÏùåÎÇ† ÎÇ†Ïî®Îßå Í∞ÄÏ†∏ÏôÄÏÑú Ïò§Îäò ÎÇ†Ïî®ÏôÄ ÎπÑÍµê
        LocalDate targetDate = issueContext.getTargetDateTime().plusDays(1).toLocalDate();
        Weather tomorrowWeather = weathers.stream()
            .filter(
                weather -> LocalDateTime.ofInstant(weather.getForecastAt(), SEOUL_ZONE_ID)
                    .toLocalDate().isEqual(targetDate))
            .max((w1, w2) -> w1.getForecastAt().compareTo(w2.getForecastAt()))
            .orElse(null);

        if (tomorrowWeather == null) {
            log.info("[WeatherBatchWriter] ÎÇ¥Ïùº ÏòàÎ≥¥ ÏóÜÏùå locationId={}", location.getId());
            return;
        }

        NotificationDecision decision = evaluateNotification(latestTodayWeather,
            tomorrowWeather);

        if (!decision.shouldNotify()) {
            log.info("[WeatherBatchWriter] ÏïåÎ¶º Ï°∞Í±¥ ÎØ∏Ï∂©Ï°± locationId={} reason={}",
                location.getId(), decision.reason());
            return;
        }

        log.info("[WeatherBatchWriter] ÏïåÎ¶º Ï†ÑÏÜ° locationId={} targetCount={} reason={}",
            location.getId(),
            profileIds.size(),
            decision.reason());
        for (UUID profileId : profileIds) {
            notificationService.createWeatherNotification(profileId, decision.reason());
        }
    }


    private NotificationDecision evaluateNotification(Weather latestTodayWeather,
        Weather tomorrowWeather) {
        log.info("[WeatherBatchWriter] ÏïåÎ¶ºÏÉùÏÑ±Ïö© ÎÇ†Ïî® ÎπÑÍµê");

        if (latestTodayWeather == null || tomorrowWeather == null) {
            return NotificationDecision.create(false, null);
        }

        PrecipitationType todayPrecipitation = latestTodayWeather.getPrecipitationType();
        PrecipitationType tomorrowPrecipitation = tomorrowWeather.getPrecipitationType();
        SkyStatus todaySky = latestTodayWeather.getSkyStatus();
        SkyStatus tomorrowSky = tomorrowWeather.getSkyStatus();

        Double todayMinTemperature = latestTodayWeather.getTemperatureMin();
        Double tomorrowMinTemperature = tomorrowWeather.getTemperatureMin();
        Double temperatureDiff = (todayMinTemperature != null && tomorrowMinTemperature != null)
            ? tomorrowMinTemperature - todayMinTemperature
            : null;

        boolean todayIsWet = todayPrecipitation != null
            && todayPrecipitation != PrecipitationType.NONE;
        boolean tomorrowIsWet = tomorrowPrecipitation != null
            && tomorrowPrecipitation != PrecipitationType.NONE;
        boolean todayIsCloudy = todaySky != null && todaySky != SkyStatus.CLEAR;
        boolean tomorrowIsClear = (tomorrowSky != null && tomorrowSky == SkyStatus.CLEAR)
            && !tomorrowIsWet;
        boolean todayIsClear = (todaySky != null && todaySky == SkyStatus.CLEAR)
            && !todayIsWet;

        List<String> reasons = new ArrayList<>();

        if ((todayIsWet || todayIsCloudy) && tomorrowIsClear) {
            reasons.add("üåû ÎÇ¥ÏùºÏùÄ ÎÇ†Ïî®Í∞Ä ÌôîÏ∞ΩÌï¥ÏßëÎãàÎã§.");
        }
        if (todayIsClear && tomorrowIsWet) {
            reasons.add("‚òîÔ∏è ÎÇ¥ÏùºÏùÄ ÎπÑÍ∞Ä Ïò§ÎÑ§Ïöî. Ïö∞ÏÇ∞ÏùÑ Ï±ôÍ∏∞ÏÑ∏Ïöî.");
        }
        if (temperatureDiff != null && temperatureDiff <= -3) {
            reasons.add("ÎÇ¥ÏùºÏùÄ ÏùºÍµêÏ∞®Í∞Ä ÌÅΩÎãàÎã§. ÎëêÍ∫ºÏö¥ Ïò∑ÏùÑ ÎåÄÎπÑÌïòÏÑ∏Ïöî.");
        } else if (temperatureDiff != null && temperatureDiff >= 3) {
            reasons.add("ÎÇ¥ÏùºÏùÄ Ïò§ÎäòÎ≥¥Îã§ ÎçîÏõåÏßëÎãàÎã§. ÏñáÍ≤å ÏûÖÏúºÏÑ∏Ïöî.");
        }

        log.info(
            "[WeatherBatchWriter] ÎπÑÍµê Í≤∞Í≥º todayWet={} todayCloudy={} tomorrowClear={} tomorrowWet={} tempDiff={} reasons={}"
            , todayIsWet, todayIsCloudy, tomorrowIsClear, tomorrowIsWet,
            temperatureDiff, reasons);

        if (reasons.isEmpty()) {
            return NotificationDecision.create(false, null);
        }

        return NotificationDecision.create(true, String.join(" ", reasons));
    }


    private WeatherFactory resolveFactory(Map<String, WeatherFactory> factories, String provider) {
        String beanName = switch (provider) {
            case "kma" -> "kmaWeatherFactory";
            case "openWeather" -> "openWeatherFactory";
            case "meteo" -> "openMeteoFactory";
            default -> throw new IllegalArgumentException(
                "ÏßÄÏõêÌïòÏßÄ ÏïäÎäî weather provider ÏûÖÎãàÎã§: " + provider);
        };
        WeatherFactory factory = factories.get(beanName);
        if (factory == null) {
            throw new IllegalStateException(
                "WeatherFactory ÎπàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. beanName=" + beanName);
        }
        return factory;
    }

    private WeatherExternalAdapter resolveAdapter(Map<String, WeatherExternalAdapter> adapters,
        String provider) {
        String beanName = switch (provider) {
            case "kma" -> "kmaApiAdapter";
            case "openWeather" -> "openWeatherAdapter";
            case "meteo" -> "openMeteoAdapter";
            default -> throw new IllegalArgumentException(
                "ÏßÄÏõêÌïòÏßÄ ÏïäÎäî weather provider ÏûÖÎãàÎã§: " + provider);
        };
        WeatherExternalAdapter adapter = adapters.get(beanName);
        if (adapter == null) {
            throw new IllegalStateException(
                "WeatherExternalAdapter ÎπàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. beanName=" + beanName);
        }
        return adapter;
    }

    private record NotificationDecision(boolean shouldNotify, String reason) {

        static NotificationDecision create(boolean shouldNotify, String reason) {
            return new NotificationDecision(shouldNotify, reason);
        }
    }
}
